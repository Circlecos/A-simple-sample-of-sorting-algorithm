### 前言

开坑！然后。。。没有然后 就这样
[github地址][2]

---

### 提纲

1. 插入排序&希尔排序
2. 计数排序
3. 选择排序
4. 冒泡排序
5. 快速排序
6. 归并排序
7. 基数排序
8. 桶排序
9. 堆排序
10. 列排序

- - -

### 1.插入排序&希尔排序

##### 插入排序( insertion sort )

就是找到原有序序列中新元素要插入的位置然后把新元素放进去

**核心代码：**

    for (j=1;j<n;j++)
    {
        key=s[j];
        i=j-1;
        while ((i>=0)&&(s[i]>key))
        {
            s[i+1]=s[i];
            i=i-1;
        }
        s[i+1]=key;
    }

**时间复杂度：** O(n^2)
**空间复杂度：** O(1)
**算法稳定性：** 稳定

##### 希尔排序( shell sort )

是直接插入排序的改进版本， 也称缩小增量排序。简单的说就是把序列分组处理

**核心代码：**

    for (gap=n/2;gap>0;gap/=2)
    {
        for (i=0;i<gap;i++)
        {
            for (j=i+gap;j<n;j+=gap)
            {
                key=s[j];
                k=j-gap;
                while ((k>=0)&&(s[k]>key))
                {
                    s[k+gap]=s[k];
                    k=k-gap;
                }
                s[k+gap]=key;
            }
        }
    }

**时间复杂度：** O(n^1.25) （时间复杂度根据增量变化）
**空间复杂度：** O(1)
**算法稳定性：** 不稳定

- - -

### 2.计数排序（counting sort）

> 计数排序对输入的数据有附加的限制条件：
> 1. 输入的线性表的元素属于有限偏序集S；
> 2. 设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。

*（PS:好像要跑相当远啊有限偏序集，先放着，恩)*

我的理解是 在 1 4 7 6 2 3 这个数列中，比4小的有三个，那毫无疑问生成的数列（1 2 3 4 6 7）中4排在第四位
计数排序是一个**非基于比较**的排序算法，而且需要处理重复数据的情形 比较排序算法下界O（nlogn） 所以这个算法有时候会比比较排序算法快

**核心代码：**

    for (i=0;i<=k;i++)
        c[i]=0;
    for (j=0;j<n;j++)
        c[s[j]]++;
    for (i=1;i<=k;i++)   
        c[i]=c[i]+c[i-1];
    for (j=n-1;j>=0;j--)
    {
        out[c[s[j]]-1]=s[j];
        c[s[j]]=c[s[j]]-1;
    }

**时间复杂度：** O(n+k)

> 假设n个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。当k=O(n)时，运行时间为O(n)。——《算法导论》

**空间复杂度：** O(n+k)
**算法稳定性：** 稳定

- - -

### 3.选择排序（selection sort）

选出数列中最小的那个放在第一位 重复这个过程就好啦

**核心代码：**

    for (i=0;i<n-1;i++)
    {
        min=i;
        for (j=i+1;j<n;j++)
            if (s[j]<s[min])
                min=j;
        swap=s[i];s[i]=s[min];s[min]=swap;
    }

**时间复杂度：** O(n^2)

**空间复杂度：** O(1)
**算法稳定性：** 不稳定

- - -

### 4.冒泡排序（bubble sort）

把小的元素一点点往前调  好像泡泡自己冒上来23333333

**核心代码：**

    for (j=0;j<n-1;j++)
    {
        for (i=0;i<n-1-j;i++)
            if (s[i]>s[i+1])
            { swap=s[i];s[i]=s[i+1];s[i+1]=swap;}
    }
**时间复杂度：** O（n^2）
**空间复杂度：** O（1）
**算法稳定性：** 稳定

- - -

### 5.快速排序（quick sort）

>  通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

快排，以前是靠背的，现在。。。还是很难自己写
不过居然有`qsort( )`在stdlib.h里面真开心hhhh

> 头文件：stdlib.h
用 法： void qsort(void *base,int nelem,int width,int (*fcmp)(const void *,const void *));
参数：
1 待排序数组首地址
2 数组中待排序元素数量
3 各元素的占用空间大小
4 指向函数的指针，用于确定排序的顺序
*(来自 百度百科)*

然后 据我一个高中NOIP的同学说 他用快排都是直接STL的 查了一下STL里面有个`sort( )` 好的我决定留坑[STL sort 函数实现详解 by fengcc][1]

**核心代码：**

     int quicksort(int *a,int l,int r)
     {
         int i,j,key;

         if ( l>=r ) return 0;
         i=l;j=r;key=a[i];
         while (i<j)
         {
             while ((i<j)&&(key<=a[j]))
                 j--;
             a[i]=a[j];
             while ((i<j)&&(key>=a[i]))
                 i++;
             a[j]=a[i];
         }
         a[i]=key;
         quicksort(a,l,i-1);
         quicksort(a,i+1,r);
         return 0;
     }

**时间复杂度：** O(nlogn)
**空间复杂度：** O(logn)
**算法稳定性：** 不稳定

- - -

### 6.归并排序（merge sort）

分治法，对两个子序列归并排序

**核心代码：**

     int MergeSort(int *a,int le,int ri)
     {
         int q;
         if (le<ri)
         {
             q=(le+ri)/2;
             MergeSort(a,le,q);
             MergeSort(a,q+1,ri);
             Merge(a,le,q+1,ri);
         }
     }

**时间复杂度：** O（nlogn)
**空间复杂度：** O（n)
**算法稳定性：** 稳定

- - -

### 7.基数排序（radix sort）

> 基数排序是先按**最低有效位**进行排序来解决卡片排序问题的。 ——《算法导论》

看起来很反常规但是我简单的这样理解
较高有效位进行比较的时候可以**忽视**较低有效位，换言之较高有效位和较低有效位不是在一个层次上
所以较高位的变化不会影响到较低位已经排好的顺序

**核心代码：**

    int dig[N];
    int di=1,k=0,flag=1,wid;//1 still have a number having k on digit i
    while (flag==1)
    {
        flag=0;
        wid=pow(10,di);
        for (k=0;k<n;k++)
        {
            dig[k]=(x[k]/(wid/10))%10;
            if (x[k]/wid!=0) flag=1;
        }   
        int i=0,j=0,c[N],y[N];
        for (i=0;i<=10;i++)
            c[i]=0;
        for (j=0;j<n;j++)
            c[dig[j]]++;
        for (i=1;i<=10;i++)   
            c[i]=c[i]+c[i-1];
        for (j=n-1;j>=0;j--)
        {
            y[c[dig[j]]-1]=x[j];
            c[dig[j]]=c[dig[j]]-1;
        }
        for (i=0;i<n;i++)
            x[i]=y[i];
        di++;
    }

**时间复杂度：** O(d(n+k)) （给定n个d位数，每一个数位有k个可能取值） *PS:程序中采用 k=10*
**空间复杂度：** O(kd+n)
**算法稳定性：** 稳定

### 8.桶排序（BucketSort）

> 桶排序将[0,1)区间划分成n个相同大小的子区间，或称为桶。然后，将n个输入数分别放到各个桶中。
> 我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶的元素列出来即可。  ——《算法导论》

**核心代码：**

    for (i=0;i<n;i++)
	{
		j=0;
		while (!((min+step*j<=a[i])&&(min+step*(j+1))))
		{
			j++;
		}
		b[j][next[j]]=a[i];
		next[j]++;
	}
	for (i=0;i<length;i++)
		InsertionSort(next[i],b[i]);
	int now=0;
	for (i=0;i<length;i++)
	{
		for (j=0;j<next[i];j++)
		{
			a[now]=b[i][j];
			now++;
		}
	}

**时间复杂度：** O(n)
**空间复杂度：** O(n+m)（m为桶的数量）
**算法稳定性：** 稳定

### 9.堆排序（HeapSort）

> 二叉堆是一个数组，它可以被看成一个近似的完全二叉树 ——《算法导论》

二叉堆可以分为最大堆和最小堆。最大堆除根节点外的节点i都满足下列不等式A[PARENT(i)]>=A[i]

开始的时候，堆排序把数据建成一个最大堆，由于数组中最大元素总在根节点A[1]中，只要不断“取出”当前状态下的A[1]，排序就可以完成。

**核心代码：**

    int HeapSize;//尚未“取出”的元素数
    int HeapLength;//总元素数

    int HeapSort(int *arr,int n)
    {
	    HeapLength=n;
	    int b[N],i,temp;

	    ChangeArray(arr,b,n);//将从0开始的数组改为从1开始，方便计算子节点和父节点的坐标
	    BuildMaxHeap(b);

    	for (i=HeapLength;i>=2;i--)
    	{
    		temp=b[1];
            b[1]=b[i];
            b[i]=temp;
            HeapSize-=1;
            MaxHeapify(b,1);//重构新的最大堆
        }

    	RecoverArray(b,arr,n);//恢复数组为从0开始
    	return 0;
}


**时间复杂度：** O(nlgn)
**空间复杂度：** O(1)
**算法稳定性：** 不稳定

### 伪·后记 2017.01.14

排序题很经典，所以真的要的话这些排序一搜就会有更好的概括
为什么我还要写呢？
又是初中复赛的那几天（咦我为什么要说又），我第一次听到了“桶排序”这个概念。不记得怎么提起来的反正我是一脸懵逼的 但是当时动规都还没太懂就要考试了就放一边去了
然后就没有然后了（瞬间想起前言的举爪让我看见你们
所以这次想起来了，就来做一份，当作是完成一个老早之前的愿望罢
顺便复习一下快排2333333333333333
嘛 先这样吧 归并虽然《算法导论》看过一遍了但是我还不太会
剩下那三个是什么可以吃的（疑惑脸
啊 我知道我没写各个算法的优化那是因为我还不会  会了我再补上

### 伪·后记 2017.02.02

用".h"把这些排序做成了一个程序 再补上了归并和基数
有点小慢……最近有点懈怠呢
快点吧还剩两个呢 恩

[1]:http://www.cnblogs.com/fengcc/p/5256337.html
[2]:https://github.com/Circlecos/sort
